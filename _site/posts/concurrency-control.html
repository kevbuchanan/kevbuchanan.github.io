<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Concurrency Control Strategies for Secret Agents</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@kevinbuch_" /><meta name="twitter:title" content="Concurrency Control Strategies for Secret Agents" /><meta name="twitter:description" content="In the 1963 movie &ldquo;Dr. No,&rdquo; the first in the James Bond series, Bond travels toJamaica for a case, and he knows that his enemies are watching his every move.He knows his enemies are sma..."><meta name="description" content="In the 1963 movie &ldquo;Dr. No,&rdquo; the first in the James Bond series, Bond travels toJamaica for a case, and he knows that his enemies are watching his..."><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/posts/concurrency-control"><link rel="alternate" type="application/atom+xml" title="Kevin Buchanan" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img src="http://www.gravatar.com/avatar/6cc41965c8245134140fc2af7e6b250e.png?s=80" class="gravatar"> </a><p class="name">Kevin Buchanan</p><span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Concurrency Control Strategies for Secret Agents</h1><time>August 17, 2015</time></div><div class="divider"></div><p>In the 1963 movie &ldquo;Dr. No,&rdquo; the first in the James Bond series, Bond travels to Jamaica for a case, and he knows that his enemies are watching his every move. He knows his enemies are smart, but he&rsquo;s smarter. To keep them from prying into his plans, he can&rsquo;t simply lock them out of his room, he needs to be a little more sly&mdash;as any reputable villain could surely pick a lock. So he places a hair on the door frame, knowing that in the sure event that his room is infiltrated while he&rsquo;s out, he&rsquo;ll see that the hair has moved and can abondon or change his plan if needed. It&rsquo;s a brilliant tactic, and saves him time, effort, and constraints on his travel that he&rsquo;d incur by trying to securely lock down his room as he moves from place to place.</p><p>How would this scenario look in code? Well, let&rsquo;s introduce a secret mission, in Ruby:</p><div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SecretMission</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@files</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="s2">&quot;File </span><span class="si">#{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">file</span> <span class="o">=</span> <span class="vi">@files</span><span class="o">.</span><span class="n">shift</span>
      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is reading </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">accept</span>
    <span class="nb">puts</span> <span class="s2">&quot;Mission Accepted&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>The mission will contain some files that need to be read. Bond will accept the mission once he reads the files. But, there are also some villains out there trying to read the files.</p><div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">mission</span> <span class="o">=</span> <span class="no">SecretMission</span><span class="o">.</span><span class="n">new</span>
<span class="n">villains</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;Odd Job&quot;</span><span class="p">,</span> <span class="s2">&quot;Jaws&quot;</span><span class="p">,</span> <span class="s2">&quot;May Day&quot;</span><span class="o">]</span>
<span class="n">threads</span> <span class="o">=</span> <span class="o">[]</span>

<span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
  <span class="n">mission</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;Bond&quot;</span><span class="p">)</span>
  <span class="n">mission</span><span class="o">.</span><span class="n">accept</span>
<span class="k">end</span>

<span class="n">villains</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">spy</span><span class="o">|</span>
  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
    <span class="n">mission</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">spy</span><span class="p">)</span> <span class="k">if</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">threads</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
</code></pre></div><p>With everything running in a separate thread, we get something like this output:</p><div class="highlight"><pre><code class="language-text" data-lang="text">Bond is reading File 1
Odd Job is reading File 2
Jaws is reading File 3
Bond is reading File 4
Jaws is reading File 5
Mission Accepted
</code></pre></div><p>Since there&rsquo;s no coordination of who is reading the files, a couple spies can sneak in. This is bad news. Bond just accepted a doomed mission because he didn&rsquo;t realize that his plans were being read by the villains at the same time.</p><p>Maybe we can make him a little safer if we lock down the files when they&rsquo;re being read. We could add a mutex to the <code>SecretMission</code> class to use when reading the files:</p><div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SecretMission</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@files</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="s2">&quot;File </span><span class="si">#{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
    <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">until</span> <span class="vi">@mutex</span><span class="o">.</span><span class="n">try_lock</span>
      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is waiting&quot;</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="nb">puts</span> <span class="s2">&quot;The files are gone!&quot;</span> <span class="k">if</span> <span class="vi">@files</span><span class="o">.</span><span class="n">empty?</span>
    <span class="k">while</span> <span class="n">file</span> <span class="o">=</span> <span class="vi">@files</span><span class="o">.</span><span class="n">shift</span>
      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is reading </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="vi">@mutex</span><span class="o">.</span><span class="n">unlock</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">accept</span>
    <span class="nb">puts</span> <span class="s2">&quot;Mission Accepted&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Now when we run our spies in separate threads, we consistently see something like this (assuming Bond&rsquo;s thread is the first to read):</p><div class="highlight"><pre><code class="language-text" data-lang="text">Bond is reading File 1
May Day is waiting
Bond is reading File 2
Bond is reading File 3
May Day is waiting
Bond is reading File 4
Bond is reading File 5
Mission Accepted
The files are gone!
</code></pre></div><p>Bond gets to the files, acquires the lock, and the other threads are locked out for the duration of his reading. But, let&rsquo;s assume that using this lock is time consuming and really draining the MI6 budget. Furthermore, once Bond has the lock, the other spies have to wait around for the lock to be available, and they just cause trouble.</p><p>So let&rsquo;s try to emulate Bond&rsquo;s hair on the door trick and allow us to check whether any villains have caught up to him so that we can then abort the mission and throw them off of his tracks.</p><p>First, let&rsquo;s change our <code>read</code> method to return how many files are read, and change the <code>accept</code> method to take a parameter for how many files a spy was able to read.</p><div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SecretMission</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@files</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="s2">&quot;File </span><span class="si">#{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">&quot;The files are gone!&quot;</span> <span class="k">if</span> <span class="vi">@files</span><span class="o">.</span><span class="n">empty?</span>
    <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">file</span> <span class="o">=</span> <span class="vi">@files</span><span class="o">.</span><span class="n">shift</span>
      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is reading </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">read</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="n">read</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">read</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">read</span> <span class="o">==</span> <span class="mi">5</span>
      <span class="nb">puts</span> <span class="s2">&quot;Mission Accepted&quot;</span>
    <span class="k">else</span>
      <span class="nb">puts</span> <span class="s2">&quot;Abort Mission!&quot;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Then, let&rsquo;s change Bond&rsquo;s behavior so that he can signal how many files he got to:</p><div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
  <span class="n">files_read</span> <span class="o">=</span> <span class="n">mission</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;Bond&quot;</span><span class="p">)</span>
  <span class="n">mission</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span><span class="n">files_read</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>Now, we could see Bond read all of the files successfully if none of the villains find them, or we could see something like this:</p><div class="highlight"><pre><code class="language-text" data-lang="text">Bond is reading File 1
Odd Job is reading File 2
Odd Job is reading File 4
Bond is reading File 3
Odd Job is reading File 5
Abort Mission!
</code></pre></div><p>This is a nice, lightweight option that allows us to always know whether the mission is compromised, without any waiting by any of the spies.</p><h2 id="from-pessimistic-to-optimistic-locking">From Pessimistic to Optimistic Locking</h2><p>What we&rsquo;ve done here is moved the concurrency control mechanism from a pessimistic lock using a mutex, to optimistic concurrency control, which assumes that nobody else is reading our files&mdash;until we verify that assumption at the end of our transaction. If we were using a database to read and write our data, we could use a pessimistic lock by obtaining a lock for a specific row in the database.</p><p>Let&rsquo;s use another example, in which we have orders that we want to cancel. We can only cancel orders if they are currently in a &ldquo;pending&rdquo; state. It also causes a lot of problems to cancel an order twice, or an order that is not pending. But we have lots of updates happening concurrently, so we need some way to maintain the integrity of our concurrent state transitions. We could start with a pessimistic lock. We&rsquo;ll assume we&rsquo;re using ActiveRecord for this example.</p><div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">order_id</span><span class="p">)</span>
<span class="n">order</span><span class="o">.</span><span class="n">with_lock</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;pending&#39;</span>
    <span class="n">order</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="ss">status</span><span class="p">:</span> <span class="s1">&#39;cancelled&#39;</span> <span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>If we&rsquo;re using PostgreSQL as our database, this will perform a <code>SELECT FOR UPDATE</code> on the record prior to yielding to the block to perform. Once this transaction gains the lock through the <code>SELECT FOR UPDATE</code>, the database will not allow other transactions to modify the row until our transaction is committed, after the block finishes. This gives us assurance that nothing else will change the order while the current thread is using it. But sometimes this is a heavy tool for the job. For one, any other threads trying to use the row will block, which could degrade our performance.</p><p>We could avoid the need to acquire a lock, and wait for the lock, by changing this procedure to an optimistic lock. All we need to do is tell the database the state of the object that we have, and let it confirm that that is indeed the current state. If it is not the current state, we know that another transaction was working at the same time. We can do this by using an <code>UPDATE WHERE</code>. In ActiveRecord that would look like this:</p><div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>

<span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;pending&#39;</span>
  <span class="n">rows_affected</span> <span class="o">=</span> <span class="no">Order</span><span class="o">.</span><span class="n">where</span><span class="p">({</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">order_id</span><span class="p">,</span>
    <span class="ss">status</span><span class="p">:</span> <span class="s1">&#39;pending&#39;</span>
  <span class="p">})</span><span class="o">.</span><span class="n">update_all</span><span class="p">({</span> <span class="ss">status</span><span class="p">:</span> <span class="s1">&#39;cancelled&#39;</span> <span class="p">})</span>

  <span class="k">raise</span> <span class="no">StaleDataError</span> <span class="k">if</span> <span class="n">rows_affected</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div><p>The above query should generate the SQL:</p><p><code>UPDATE orders SET orders.status=&#39;cancelled&#39; WHERE orders.id=25 AND orders.status=&#39;pending&#39;;</code></p><p>A SQL update returns the number of rows that were updated, so we can check the return value from our update and know that we&rsquo;ve run into concurrent updates if our update returns <code>0</code>.</p><p><em>Note: If you&rsquo;re using ActiveRecord, or another ORM to do a similar optimistic lock, you should confirm that this is actually the SQL that gets generated. I&rsquo;ve seen ActiveRecord convert queries like this to a sub-select, which negates the benefit of our lock because we&rsquo;re left with a race condition between when the sub-select executes and when other concurrent updates commit.</em></p><h2 id="multi-version-concurrency-control">Multi-Version Concurrency Control</h2><h3 id="postgresql">PostgreSQL</h3><p>Although our optimistic locking strategy isn&rsquo;t explicity acquiring a lock, we could still block other transactions. Certain databases might block both reads and writes while we are performing the update. PostgreSQL will only block other writes. When using an optimistic locking strategy in PostgreSQL, it&rsquo;s important to know why this works, and how it affects other transactions. In order to perform our <code>UPDATE WHERE</code> while maintaining our data consistency and also not blocking other threads from reading data, PostgreSQL uses a technique called Multi-Version Concurrency Control (MVCC). Other databases also use this pattern, but I&rsquo;ll focus on PostgreSQL here.</p><p>PostgreSQL executes each statement inside of a transaction with the <em>Read Committed</em> isolation level. An isolation level determines what kinds of changes to data are shared between transactions. There are other isolation levels available, but <em>Read Committed</em> is the default. In <em>Read Committed</em> isolation, PostgreSQL allows other threads to read the row without blocking, though other updates will need to wait for other concurrent updates to complete. How does this work? Well, the key here is that each record in the database isn&rsquo;t just one row. It&rsquo;s actually many rows that PostgreSQL is constantly marking as unavailable after updates or deletes, and available as they become the most recent version (it&rsquo;s actually a slightly more complicated process of comparing transaction IDs stored in <a href="http://www.postgresql.org/docs/9.4/static/ddl-system-columns.html">system columns</a>, but let&rsquo;s use this simplification). PostgreSQL eventually goes back and cleans up the unavailable rows through the <a href="http://www.postgresql.org/docs/9.4/static/routine-vacuuming.html#AUTOVACUUM"><em>autovacuum</em></a> process.</p><p>So, back to our example, say we execute our query at time <code>T1</code>:</p><p><code>BEGIN; UPDATE orders SET orders.status=&#39;cancelled&#39; WHERE orders.id=25 AND orders.status=&#39;pending&#39;; COMMIT;</code></p><p>PostgreSQL begins a transaction in <em>Read Committed</em> isolation, and for the duration of this transaction it will only see data committed and marked as available prior to <code>T1</code>. Then, say we execute a concurrent query at time <code>T2</code> to:</p><p><code>BEGIN; SELECT status FROM orders WHERE orders.id=25; COMMIT;</code></p><p>This <code>SELECT</code> will only see row versions that were committed and available prior to <code>T2</code>. Assuming we only have these two queries running, the <code>SELECT</code> will see the same version of the row that our first <code>UPDATE</code> is seeing&mdash;that which was committed prior to <code>T1</code>, with the status as &ldquo;pending&rdquo;. So this query will return &ldquo;pending&rdquo;. (Side note: a <code>SELECT</code> will also see data changed by an <code>UPDATE</code> within its own transaction).</p><p>Let&rsquo;s throw in another update and see what happens. Assume our <code>SELECT</code> completed at time <code>T3</code> and returned &ldquo;pending&rdquo;, but our <code>UPDATE</code> is still running. Another transaction might start at time <code>T4</code> to actually start the order:</p><p><code>BEGIN; UPDATE orders SET orders.status=&#39;started&#39; WHERE orders.id=25 AND orders.status=&#39;pending&#39;; COMMIT;</code></p><p>This transaction will see the version of the data committed prior to <code>T1</code> and our first update, so it will find a row with ID 25 and status &ldquo;pending&rdquo;. But it will see that the row is currently held by a <em>ROW EXCLUSIVE</em> lock in our first transaction, so it will need to wait. Let&rsquo;s assume the first update commits at <code>T5</code>. Our second update now gets to re-apply its query to the row version as of <code>T5</code>, so it will see that the status is now not equal to &ldquo;pending&rdquo;, and it will not update the status to &ldquo;started&rdquo;.</p><p>So, we&rsquo;re still eventually locking a row in our database, but the benefit of doing this through PostgreSQL&rsquo;s MVCC implementation is that we minimize the amount of time that a lock is held, and the amount of time that our threads spend waiting to proceed with our business logic. This could be good or bad depending on how our program is structured.</p><p>If we perform some side effect-y things prior to updating the order, such as sending a notification that the order is started, then we&rsquo;ve actually been notified about the concurrent update too late. On the other hand, if we do the update before the business logic, then we know right away whether we can proceed and avoid blocking while another thread performs its business logic. When we use <code>SELECT FOR UPDATE</code> by using <code>order.with_lock</code> in ActiveRecord, other threads will halt on trying to acquire the lock while the first executes the in-memory logic and the database update. In many situations, but not all, it&rsquo;s more effecient to be optimistic and let things proceed until we know that we&rsquo;ve actually encountered a concurrency issue.</p><h3 id="clojure-stm">Clojure STM</h3><p>Let&rsquo;s take this full circle and see what a MVCC implementation of our secret file example would look like. For an in-memory implementation, we can use Clojure, as Clojure&rsquo;s refs are implemented using Software Transactional Memory (STM) with MVCC.</p><div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">spies.core</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">files</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">mapv</span> <span class="o">#</span><span class="p">(</span><span class="nf">format</span> <span class="s">&quot;File %s&quot;</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">%</span><span class="p">)))</span>
       <span class="nv">ref</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">read-file</span> <span class="p">[</span><span class="nv">spy</span> <span class="nv">files</span> <span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">format</span> <span class="s">&quot;\n%s is attempting to read %s&quot;</span> <span class="nv">spy</span> <span class="nv">file</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">alter </span><span class="nv">files</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">format</span> <span class="s">&quot;\n%s is reading %s&quot;</span> <span class="nv">spy</span> <span class="nv">file</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">300</span><span class="p">)</span>
  <span class="nv">file</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">accept-mission</span> <span class="p">[</span><span class="nv">files</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">alter </span><span class="nv">files</span> <span class="p">(</span><span class="nb">constantly </span><span class="p">[</span><span class="s">&quot;A bad pun from Bond&quot;</span><span class="p">]))</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nMission Accepted&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">bond</span>
  <span class="p">(</span><span class="nf">future</span>
    <span class="p">(</span><span class="nf">dosync</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">file-read</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">read-file</span> <span class="s">&quot;Bond&quot;</span> <span class="nv">files</span> <span class="nv">%</span><span class="p">)</span> <span class="o">@</span><span class="nv">files</span><span class="p">)]</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">5</span> <span class="p">(</span><span class="nb">count </span><span class="nv">files-read</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">accept-mission</span> <span class="nv">files</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nAbort Mission&quot;</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">villainize</span> <span class="p">[</span><span class="nv">villain</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">future</span>
    <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">zero? </span><span class="p">(</span><span class="nb">rand-int </span><span class="mi">3</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">dosync</span>
        <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">file</span> <span class="p">(</span><span class="nb">first </span><span class="o">@</span><span class="nv">files</span><span class="p">)]</span>
          <span class="p">(</span><span class="nf">read-file</span> <span class="nv">villain</span> <span class="nv">files</span> <span class="nv">file</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%s, the files are gone&quot;</span> <span class="nv">villain</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">villains</span>
  <span class="p">(</span><span class="nb">map </span><span class="nv">villainize</span> <span class="p">[</span><span class="s">&quot;Odd Job&quot;</span> <span class="s">&quot;Jaws&quot;</span> <span class="s">&quot;May Day&quot;</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">-main</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">futures</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">villains</span> <span class="nv">bond</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nb">map deref </span><span class="nv">futures</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">shutdown-agents</span><span class="p">))</span>
</code></pre></div><p>In this code, we create a group of threads to read the files using <code>future</code>. Bond&rsquo;s thread will try to read all the files and then leave a note for the villains, whereas the villains will only try to read one file. The files are kept in a <code>ref</code>, which will only allow mutation while inside a transaction using <code>dosync</code>. While in the transaction, we can change the ref by using <code>alter</code>, which takes as arguments a ref and a function to call to alter the ref. When we run this, we see something like this:</p><div class="highlight"><pre><code class="language-text" data-lang="text">Bond is attempting to read File 1
Bond is reading File 1
Jaws is attempting to read File 1
Odd Job is attempting to read File 1
Bond is attempting to read File 2
Bond is reading File 2
Odd Job is attempting to read File 1
Bond is attempting to read File 3
Jaws is attempting to read File 1
Bond is reading File 3
Bond is attempting to read File 4
Bond is reading File 4
Bond is attempting to read File 5
Bond is reading File 5
Odd Job is attempting to read File 1
Jaws is attempting to read File 1
Mission Accepted
Jaws is attempting to read A bad pun from Bond
Odd Job is attempting to read A bad pun from Bond
Jaws is reading A bad pun from Bond
Odd Job, the files are gone
Jaws, the files are gone
</code></pre></div><p>You&rsquo;ll notice that the threads trying to read for Jaws and Odd Job retried a number of times while Bond&rsquo;s thread was reading the files. This is caused by Clojure&rsquo;s LockingTransaction implementation retrying the call to <code>alter</code> if the transaction can&rsquo;t obtain a write lock or if it finds that the ref has been altered since its read point. No threads are blocked from reading the files, but once a thread makes a call to <code>alter</code>, it tries to acquire a write lock, and if it can&rsquo;t, it will retry from the beginning of the transaction starting from <code>dosync</code>.</p><p>Each thread sees the last committed version of the files when the transaction started. So to start, each villain thread will see that there are five files in the ref, and will try to remove one to be read by the spy by calling <code>alter</code>. However, Bond&rsquo;s transaction has the write lock, so the other transactions will retry the <code>alter</code> of the first file a number of times, until Bond&rsquo;s transaction commits and releases the write lock. Then the villain threads will retry again because Clojure&rsquo;s STM detects that the ref has changed. This time they see the version of the ref that Bond committed, with only his note left.</p><h2 id="tradeoffs">Tradeoffs</h2><p>Given your options for concurrency control strategies&mdash;pessimistic/locking, optimistic/lock-free, or MVCC/hybrid&mdash;which one should you use? Well, like most decisions when writing software, it comes down to your needs for the specific problem you&rsquo;re trying to solve. Each of these strategies present different tradeoffs that should be taken into account. To sum up, here&rsquo;s what you get with each:</p><h4 id="pessimistic-locking">Pessimistic/Locking:</h4><p><strong>Benefits:</strong></p><ul><li>Exclusive access</li><li>Possible stronger guarantee of integrity</li></ul><p><strong>Drawbacks:</strong></p><ul><li>Lock contention</li><li>Records are possibly completely inaccesible by other processes depending on implementation</li></ul><h4 id="optimistic-lock-free">Optimistic/Lock-Free:</h4><p><strong>Benefits:</strong></p><ul><li>Lower overhead</li><li>No waiting or lock contention</li></ul><p><strong>Drawbacks:</strong></p><ul><li>Deciding how to handle collisions or stale data</li><li>Possibility of retrying operations with side-effects</li></ul><h4 id="mvcc-hybrid">MVCC/Hybrid:</h4><p><strong>Benefits:</strong></p><ul><li>Reads are never blocked</li><li>Reads never block writes</li></ul><p><strong>Drawbacks:</strong></p><ul><li>Cost of maintaining multiple versions of records (e.g. autovacuum)</li><li>Handling retried transactions or stale data</li><li>Isolation levels vary between implementations</li></ul><p>When trying to solve a concurrency problem, keep in mind that there are many strategies available to you, and pick the one that best suits your specific needs. You don&rsquo;t always need the brute force of a pessimistic lock. Bond knew the villians would break in, he just wouldn&rsquo;t know when or what they had access to without the hair. You too can embrace the challenges of concurrency through different concurrency control strategies. With the right choice, you can thwart would-be concurrent invasions into your process just like a secret agent.</p><h4 id="references">References</h4><ul><li><a href="http://www.postgresql.org/docs/9.4/static/mvcc.html">PostgreSQL</a></li><li><a href="http://blog.2ndquadrant.com/postgresql-anti-patterns-read-modify-write-cycles/">PostgreSQL Anti-Patterns</a></li><li><a href="http://www.keithf4.com/checking-for-postgresql-bloat/">PostgreSQL Versioning and Bloat</a></li><li><a href="http://martin.kleppmann.com/2014/11/25/hermitage-testing-the-i-in-acid.html">Testing the I in ACID</a></li><li><a href="http://clojure.org/refs">Clojure Refs</a></li><li><a href="http://blog.jayfields.com/2011/04/clojure-state-management.html">Jay Fields on Clojure Refs</a></li></ul></article><div class="back"> <a href="/">Back</a></div></main></body></html>
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


  <title>Concurrency Control Strategies for Secret Agents | KB</title>


<meta name="description" content="In the 1963 movie “Dr. No,” the first in the James Bond series, Bond travels toJamaica for a case, and he knows that his enemies are watching his every move....">

<link rel="apple-touch-icon" href="/assets/touch-icon.png">
<link href="https://fonts.googleapis.com/css?family=Libre+Franklin" rel="stylesheet">
<link rel="stylesheet" href="/assets/core.css">
<link rel="canonical" href="/posts/concurrency-control">
<link rel="alternate" type="application/atom+xml" title="Blog" href="/feed.xml" />

  </head>

  <body>

    <header>
  

  <img src="/assets/photo.jpg">

  <h4>Kevin Buchanan</h4>

  <a href="/">
    Posts
  </a>

</header>


    <main>
      <article>
  <section class="title">
    <h1>Concurrency Control Strategies for Secret Agents</h1>
    <time>August 17, 2015</time>
  </section>

  <section class="content">
    <p>In the 1963 movie “Dr. No,” the first in the James Bond series, Bond travels to
Jamaica for a case, and he knows that his enemies are watching his every move.
He knows his enemies are smart, but he’s smarter. To keep them from prying
into his plans, he can’t simply lock them out of his room, he needs to be a
little more sly—as any reputable villain could surely pick a lock. So he
places a hair on the door frame, knowing that in the sure event that his room
is infiltrated while he’s out, he’ll see that the hair has moved and can
abondon or change his plan if needed. It’s a brilliant tactic, and saves
him time, effort, and constraints on his travel that he’d incur by trying
to securely lock down his room as he moves from place to place.</p>

<p>How would this scenario look in code? Well, let’s introduce a secret mission,
in Ruby:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SecretMission</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@files</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="s2">"File </span><span class="si">#{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">file</span> <span class="o">=</span> <span class="vi">@files</span><span class="p">.</span><span class="nf">shift</span>
      <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is reading </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">"</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">accept</span>
    <span class="nb">puts</span> <span class="s2">"Mission Accepted"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The mission will contain some files that need to be read. Bond
will accept the mission once he reads the files. But, there are also some
villains out there trying to read the files.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mission</span> <span class="o">=</span> <span class="no">SecretMission</span><span class="p">.</span><span class="nf">new</span>
<span class="n">villains</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Odd Job"</span><span class="p">,</span> <span class="s2">"Jaws"</span><span class="p">,</span> <span class="s2">"May Day"</span><span class="p">]</span>
<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">mission</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"Bond"</span><span class="p">)</span>
  <span class="n">mission</span><span class="p">.</span><span class="nf">accept</span>
<span class="k">end</span>

<span class="n">villains</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">spy</span><span class="o">|</span>
  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">mission</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">spy</span><span class="p">)</span> <span class="k">if</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">threads</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
</code></pre></div></div>

<p>With everything running in a separate thread, we get something like this output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bond is reading File 1
Odd Job is reading File 2
Jaws is reading File 3
Bond is reading File 4
Jaws is reading File 5
Mission Accepted
</code></pre></div></div>

<p>Since there’s no coordination of who is reading the files, a couple
spies can sneak in. This is bad news. Bond just accepted a doomed mission
because he didn’t realize that his plans were being read by the villains
at the same time.</p>

<p>Maybe we can make him a little safer if we lock down the files when
they’re being read. We could add a mutex to the <code class="highlighter-rouge">SecretMission</code> class
to use when reading the files:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SecretMission</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@files</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="s2">"File </span><span class="si">#{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
    <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">until</span> <span class="vi">@mutex</span><span class="p">.</span><span class="nf">try_lock</span>
      <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is waiting"</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="nb">puts</span> <span class="s2">"The files are gone!"</span> <span class="k">if</span> <span class="vi">@files</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">while</span> <span class="n">file</span> <span class="o">=</span> <span class="vi">@files</span><span class="p">.</span><span class="nf">shift</span>
      <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is reading </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">"</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="vi">@mutex</span><span class="p">.</span><span class="nf">unlock</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">accept</span>
    <span class="nb">puts</span> <span class="s2">"Mission Accepted"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now when we run our spies in separate threads, we consistently see something
like this (assuming Bond’s thread is the first to read):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bond is reading File 1
May Day is waiting
Bond is reading File 2
Bond is reading File 3
May Day is waiting
Bond is reading File 4
Bond is reading File 5
Mission Accepted
The files are gone!
</code></pre></div></div>

<p>Bond gets to the files, acquires the lock, and the other threads are locked
out for the duration of his reading. But, let’s assume that using this lock is
time consuming and really draining the MI6 budget. Furthermore, once Bond has
the lock, the other spies have to wait around for the lock to be available, and
they just cause trouble.</p>

<p>So let’s try to emulate Bond’s hair on the door trick and allow us to check
whether any villains have caught up to him so that we can then abort the mission
and throw them off of his tracks.</p>

<p>First, let’s change our <code class="highlighter-rouge">read</code> method to return how many files are read, and change
the <code class="highlighter-rouge">accept</code> method to take a parameter for how many files a spy was able to read.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SecretMission</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@files</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="s2">"File </span><span class="si">#{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"The files are gone!"</span> <span class="k">if</span> <span class="vi">@files</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">file</span> <span class="o">=</span> <span class="vi">@files</span><span class="p">.</span><span class="nf">shift</span>
      <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> is reading </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">"</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
      <span class="n">read</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="n">read</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">read</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">read</span> <span class="o">==</span> <span class="mi">5</span>
      <span class="nb">puts</span> <span class="s2">"Mission Accepted"</span>
    <span class="k">else</span>
      <span class="nb">puts</span> <span class="s2">"Abort Mission!"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then, let’s change Bond’s behavior so that he can signal how many files
he got to:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">files_read</span> <span class="o">=</span> <span class="n">mission</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"Bond"</span><span class="p">)</span>
  <span class="n">mission</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">files_read</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, we could see Bond read all of the files successfully if none of the
villains find them, or we could see something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bond is reading File 1
Odd Job is reading File 2
Odd Job is reading File 4
Bond is reading File 3
Odd Job is reading File 5
Abort Mission!
</code></pre></div></div>

<p>This is a nice, lightweight option that allows us to always know whether
the mission is compromised, without any waiting by any of the spies.</p>

<h2 id="from-pessimistic-to-optimistic-locking">From Pessimistic to Optimistic Locking</h2>

<p>What we’ve done here is moved the concurrency control mechanism from
a pessimistic lock using a mutex, to optimistic concurrency control, which
assumes that nobody else is reading our files—until we verify that assumption
at the end of our transaction. If we were using a database to read and write
our data, we could use a pessimistic lock by obtaining a lock for a specific
row in the database.</p>

<p>Let’s use another example, in which we have orders that we want to cancel. We
can only cancel orders if they are currently in a “pending” state. It also
causes a lot of problems to cancel an order twice, or an order that is not pending.
But we have lots of updates happening concurrently, so we need some way to maintain the
integrity of our concurrent state transitions. We could start with a
pessimistic lock. We’ll assume we’re using ActiveRecord for this example.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">order_id</span><span class="p">)</span>
<span class="n">order</span><span class="p">.</span><span class="nf">with_lock</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">order</span><span class="p">.</span><span class="nf">status</span> <span class="o">==</span> <span class="s1">'pending'</span>
    <span class="n">order</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span> <span class="ss">status: </span><span class="s1">'cancelled'</span> <span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If we’re using PostgreSQL as our database, this will perform a <code class="highlighter-rouge">SELECT FOR UPDATE</code>
on the record prior to yielding to the block to perform. Once this transaction gains
the lock through the <code class="highlighter-rouge">SELECT FOR UPDATE</code>, the database will not allow other
transactions to modify the row until our transaction is committed, after the block
finishes. This gives us assurance that nothing else will change the order while the current
thread is using it. But sometimes this is a heavy tool for the job. For one,
any other threads trying to use the row will block, which could degrade our
performance.</p>

<p>We could avoid the need to acquire a lock, and wait for the lock, by changing
this procedure to an optimistic lock. All we need to do is tell the database
the state of the object that we have, and let it confirm that that
is indeed the current state. If it is not the current state, we know that
another transaction was working at the same time. We can do this by using an
<code class="highlighter-rouge">UPDATE WHERE</code>. In ActiveRecord that would look like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>

<span class="k">if</span> <span class="n">order</span><span class="p">.</span><span class="nf">status</span> <span class="o">==</span> <span class="s1">'pending'</span>
  <span class="n">rows_affected</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">where</span><span class="p">({</span>
    <span class="ss">id: </span><span class="n">order_id</span><span class="p">,</span>
    <span class="ss">status: </span><span class="s1">'pending'</span>
  <span class="p">}).</span><span class="nf">update_all</span><span class="p">({</span> <span class="ss">status: </span><span class="s1">'cancelled'</span> <span class="p">})</span>

  <span class="k">raise</span> <span class="no">StaleDataError</span> <span class="k">if</span> <span class="n">rows_affected</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">end</span>

</code></pre></div></div>

<p>The above query should generate the SQL:</p>

<p><code class="highlighter-rouge">UPDATE orders SET orders.status='cancelled' WHERE orders.id=25 AND orders.status='pending';</code></p>

<p>A SQL update returns the number of rows that were updated, so we can check the return
value from our update and know that we’ve run into concurrent updates if our update
returns <code class="highlighter-rouge">0</code>.</p>

<p><em>Note: If you’re using ActiveRecord, or another ORM to do a similar optimistic lock,
you should confirm that this is actually the SQL that gets generated. I’ve seen
ActiveRecord convert queries like this to a sub-select, which negates the
benefit of our lock because we’re left with a race condition between
when the sub-select executes and when other concurrent updates commit.</em></p>

<h2 id="multi-version-concurrency-control">Multi-Version Concurrency Control</h2>

<h3 id="postgresql">PostgreSQL</h3>

<p>Although our optimistic locking strategy isn’t explicity acquiring a lock, we could
still block other transactions. Certain databases might block both reads and writes
while we are performing the update. PostgreSQL will only block other writes.
When using an optimistic locking strategy in PostgreSQL, it’s important to
know why this works, and how it affects other transactions. In order to perform
our <code class="highlighter-rouge">UPDATE WHERE</code> while maintaining our data consistency and also not blocking
other threads from reading data, PostgreSQL uses a technique called Multi-Version
Concurrency Control (MVCC). Other databases also use this pattern, but I’ll
focus on PostgreSQL here.</p>

<p>PostgreSQL executes each statement inside of a transaction with the <em>Read
Committed</em> isolation level. An isolation level determines what kinds of changes
to data are shared between transactions. There are other isolation levels
available, but <em>Read Committed</em> is the default. In <em>Read Committed</em> isolation,
PostgreSQL allows other threads to read the row without blocking, though other
updates will need to wait for other concurrent updates to complete. How does
this work? Well, the key here is that each record in the database isn’t just
one row. It’s actually many rows that PostgreSQL is constantly marking as
unavailable after updates or deletes, and available as they become the most
recent version (it’s actually a slightly more complicated process of comparing
transaction IDs stored in <a href="http://www.postgresql.org/docs/9.4/static/ddl-system-columns.html">system columns</a>,
but let’s use this simplification). PostgreSQL eventually goes back and cleans
up the unavailable rows through the
<a href="http://www.postgresql.org/docs/9.4/static/routine-vacuuming.html#AUTOVACUUM"><em>autovacuum</em></a> process.</p>

<p>So, back to our example, say we execute our query at time <code class="highlighter-rouge">T1</code>:</p>

<p><code class="highlighter-rouge">BEGIN; UPDATE orders SET orders.status='cancelled' WHERE orders.id=25 AND orders.status='pending'; COMMIT;</code></p>

<p>PostgreSQL begins a transaction in <em>Read Committed</em> isolation, and for the
duration of this transaction it will only see data committed and marked as
available prior to <code class="highlighter-rouge">T1</code>. Then, say we execute a concurrent query at time <code class="highlighter-rouge">T2</code>
to:</p>

<p><code class="highlighter-rouge">BEGIN; SELECT status FROM orders WHERE orders.id=25; COMMIT;</code></p>

<p>This <code class="highlighter-rouge">SELECT</code> will only see row versions that were committed and available
prior to <code class="highlighter-rouge">T2</code>. Assuming we only have these two queries running, the <code class="highlighter-rouge">SELECT</code>
will see the same version of the row that our first <code class="highlighter-rouge">UPDATE</code> is
seeing—that which was committed prior to <code class="highlighter-rouge">T1</code>, with the status as
“pending”. So this query will return “pending”. (Side note: a <code class="highlighter-rouge">SELECT</code> will
also see data changed by an <code class="highlighter-rouge">UPDATE</code> within its own transaction).</p>

<p>Let’s throw in another update and see what happens. Assume our <code class="highlighter-rouge">SELECT</code> completed
at time <code class="highlighter-rouge">T3</code> and returned “pending”, but our <code class="highlighter-rouge">UPDATE</code> is still running. Another
transaction might start at time <code class="highlighter-rouge">T4</code> to actually start the order:</p>

<p><code class="highlighter-rouge">BEGIN; UPDATE orders SET orders.status='started' WHERE orders.id=25 AND orders.status='pending'; COMMIT;</code></p>

<p>This transaction will see the version of the data committed prior to <code class="highlighter-rouge">T1</code> and our first
update, so it will find a row with ID 25 and status “pending”. But it will see that the
row is currently held by a <em>ROW EXCLUSIVE</em> lock in our first transaction, so it will
need to wait. Let’s assume the first update commits at <code class="highlighter-rouge">T5</code>. Our second update now
gets to re-apply its query to the row version as of <code class="highlighter-rouge">T5</code>, so it will see that the status
is now not equal to “pending”, and it will not update the status to “started”.</p>

<p>So, we’re still eventually locking a row in our database, but the benefit of
doing this through PostgreSQL’s MVCC implementation is that we minimize the
amount of time that a lock is held, and the amount of time that our threads
spend waiting to proceed with our business logic. This could be good or bad
depending on how our program is structured.</p>

<p>If we perform some side effect-y things prior to updating the order, such as
sending a notification that the order is started, then we’ve actually been
notified about the concurrent update too late. On the other hand, if we do the
update before the business logic, then we know right away whether we can
proceed and avoid blocking while another thread performs its business logic.
When we use <code class="highlighter-rouge">SELECT FOR UPDATE</code> by using <code class="highlighter-rouge">order.with_lock</code> in ActiveRecord,
other threads will halt on trying to acquire the lock while the first executes
the in-memory logic and the database update. In many situations, but not all,
it’s more effecient to be optimistic and let things proceed until we know that
we’ve actually encountered a concurrency issue.</p>

<h3 id="clojure-stm">Clojure STM</h3>

<p>Let’s take this full circle and see what a MVCC implementation of our secret file
example would look like. For an in-memory implementation, we can use Clojure, as Clojure’s
refs are implemented using Software Transactional Memory (STM) with MVCC.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">spies.core</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">files</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"File %s"</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">
       </span><span class="nb">ref</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">read-file</span><span class="w"> </span><span class="p">[</span><span class="n">spy</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="n">file</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"\n%s is attempting to read %s"</span><span class="w"> </span><span class="n">spy</span><span class="w"> </span><span class="n">file</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="nb">rest</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"\n%s is reading %s"</span><span class="w"> </span><span class="n">spy</span><span class="w"> </span><span class="n">file</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">300</span><span class="p">)</span><span class="w">
  </span><span class="n">file</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">accept-mission</span><span class="w"> </span><span class="p">[</span><span class="n">files</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="p">(</span><span class="nb">constantly</span><span class="w"> </span><span class="p">[</span><span class="s">"A bad pun from Bond"</span><span class="p">]))</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"\nMission Accepted"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">bond</span><span class="w">
  </span><span class="p">(</span><span class="nf">future</span><span class="w">
    </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">file-read</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">read-file</span><span class="w"> </span><span class="s">"Bond"</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="o">@</span><span class="n">files</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">files-read</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="nf">accept-mission</span><span class="w"> </span><span class="n">files</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"\nAbort Mission"</span><span class="p">))))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">villainize</span><span class="w"> </span><span class="p">[</span><span class="n">villain</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">future</span><span class="w">
    </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
        </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="o">@</span><span class="n">files</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="nf">read-file</span><span class="w"> </span><span class="n">villain</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s, the files are gone"</span><span class="w"> </span><span class="n">villain</span><span class="p">)))))))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">villains</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">villainize</span><span class="w"> </span><span class="p">[</span><span class="s">"Odd Job"</span><span class="w"> </span><span class="s">"Jaws"</span><span class="w"> </span><span class="s">"May Day"</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">futures</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">villains</span><span class="w"> </span><span class="n">bond</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doall</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">deref</span><span class="w"> </span><span class="n">futures</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nf">shutdown-agents</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>In this code, we create a group of threads to read the files using <code class="highlighter-rouge">future</code>.
Bond’s thread will try to read all the files and then leave a note for
the villains, whereas the villains will only try to read one file. The files
are kept in a <code class="highlighter-rouge">ref</code>, which will only allow mutation while inside a transaction
using <code class="highlighter-rouge">dosync</code>. While in the transaction, we can change the ref by using
<code class="highlighter-rouge">alter</code>, which takes as arguments a ref and a function to call to alter the
ref. When we run this, we see something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bond is attempting to read File 1
Bond is reading File 1
Jaws is attempting to read File 1
Odd Job is attempting to read File 1
Bond is attempting to read File 2
Bond is reading File 2
Odd Job is attempting to read File 1
Bond is attempting to read File 3
Jaws is attempting to read File 1
Bond is reading File 3
Bond is attempting to read File 4
Bond is reading File 4
Bond is attempting to read File 5
Bond is reading File 5
Odd Job is attempting to read File 1
Jaws is attempting to read File 1
Mission Accepted
Jaws is attempting to read A bad pun from Bond
Odd Job is attempting to read A bad pun from Bond
Jaws is reading A bad pun from Bond
Odd Job, the files are gone
Jaws, the files are gone
</code></pre></div></div>

<p>You’ll notice that the threads trying to read for Jaws and Odd Job retried a
number of times while Bond’s thread was reading the files. This is caused by
Clojure’s LockingTransaction implementation retrying the call to <code class="highlighter-rouge">alter</code> if the
transaction can’t obtain a write lock or if it finds that the ref has been
altered since its read point. No threads are blocked from reading the files, but
once a thread makes a call to <code class="highlighter-rouge">alter</code>, it tries to acquire a write lock, and if
it can’t, it will retry from the beginning of the transaction starting from
<code class="highlighter-rouge">dosync</code>.</p>

<p>Each thread sees the last committed version of the files when the transaction started.
So to start, each villain thread will see that there are five files in the ref,
and will try to remove one to be read by the spy by calling <code class="highlighter-rouge">alter</code>. However,
Bond’s transaction has the write lock, so the other transactions will retry the
<code class="highlighter-rouge">alter</code> of the first file a number of times, until Bond’s transaction commits and
releases the write lock. Then the villain threads will retry again because
Clojure’s STM detects that the ref has changed. This time they see the version
of the ref that Bond committed, with only his note left.</p>

<h2 id="tradeoffs">Tradeoffs</h2>

<p>Given your options for concurrency control strategies—pessimistic/locking,
optimistic/lock-free, or MVCC/hybrid—which one should you use? Well,
like most decisions when writing software, it comes down to your needs for the
specific problem you’re trying to solve. Each of these strategies present
different tradeoffs that should be taken into account. To sum up, here’s what
you get with each:</p>

<h4 id="pessimisticlocking">Pessimistic/Locking</h4>

<p><strong>Benefits:</strong></p>
<ul>
  <li>Exclusive access</li>
  <li>Possible stronger guarantee of integrity</li>
</ul>

<p><strong>Drawbacks:</strong></p>

<ul>
  <li>Lock contention</li>
  <li>Records are possibly completely inaccesible by other processes depending on
implementation</li>
</ul>

<h4 id="optimisticlock-free">Optimistic/Lock-Free</h4>

<p><strong>Benefits:</strong></p>

<ul>
  <li>Lower overhead</li>
  <li>No waiting or lock contention</li>
</ul>

<p><strong>Drawbacks:</strong></p>

<ul>
  <li>Deciding how to handle collisions or stale data</li>
  <li>Possibility of retrying operations with side-effects</li>
</ul>

<h4 id="mvcchybrid">MVCC/Hybrid</h4>

<p><strong>Benefits:</strong></p>

<ul>
  <li>Reads are never blocked</li>
  <li>Reads never block writes</li>
</ul>

<p><strong>Drawbacks:</strong></p>

<ul>
  <li>Cost of maintaining multiple versions of records (e.g. autovacuum)</li>
  <li>Handling retried transactions or stale data</li>
  <li>Isolation levels vary between implementations</li>
</ul>

<p>When trying to solve a concurrency problem, keep in mind that there are many
strategies available to you, and pick the one that best suits your specific
needs. You don’t always need the brute force of a pessimistic lock. Bond knew
the villians would break in, he just wouldn’t know when or what they had access
to without the hair. You too can embrace the challenges of concurrency through
different concurrency control strategies. With the right choice, you can thwart
would-be concurrent invasions into your process just like a secret agent.</p>

<h4 id="references">References</h4>

<ul>
  <li><a href="http://www.postgresql.org/docs/9.4/static/mvcc.html">PostgreSQL</a></li>
  <li><a href="http://blog.2ndquadrant.com/postgresql-anti-patterns-read-modify-write-cycles/">PostgreSQL Anti-Patterns</a></li>
  <li><a href="http://www.keithf4.com/checking-for-postgresql-bloat/">PostgreSQL Versioning and Bloat</a></li>
  <li><a href="http://martin.kleppmann.com/2014/11/25/hermitage-testing-the-i-in-acid.html">Testing the I in ACID</a></li>
  <li><a href="http://clojure.org/refs">Clojure Refs</a></li>
  <li><a href="http://blog.jayfields.com/2011/04/clojure-state-management.html">Jay Fields on Clojure Refs</a></li>
</ul>

  </section>
</article>

<footer>
  <a href="/">Back</a>
</footer>

    </main>

  </body>

</html>
